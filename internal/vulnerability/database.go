package vulnerability

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/your-org/ccscanner/pkg/models"
)

// VulnerabilityDatabase 表示漏洞数据库
type VulnerabilityDatabase struct {
	vulnerabilities map[string][]Vulnerability // 按包名索引的漏洞列表
	lastUpdate     time.Time                  // 最后更新时间
	dataPath       string                     // 数据文件路径
	sources        []VulnerabilitySource      // 漏洞数据源
	mu             sync.RWMutex               // 读写锁
}

// Vulnerability 表示一个具体的漏洞
type Vulnerability struct {
	ID          string    `json:"id"`           // 漏洞ID
	PackageName string    `json:"packageName"`  // 受影响的包名
	Versions    []string  `json:"versions"`     // 受影响的版本
	Description string    `json:"description"`  // 漏洞描述
	Severity    string    `json:"severity"`     // 严重程度
	CVSS        float64   `json:"cvss"`        // CVSS评分
	References  []string  `json:"references"`   // 参考链接
	Published   time.Time `json:"published"`    // 发布时间
	Fixed       []string  `json:"fixed"`        // 已修复的版本
	Type        string    `json:"type"`         // 漏洞类型
	CWE         []string  `json:"cwe"`         // CWE编号
	CVE         []string  `json:"cve"`         // CVE编号
	Metadata    map[string]interface{} `json:"metadata"` // 额外元数据
}

// VulnerabilitySource 表示漏洞数据源
type VulnerabilitySource interface {
	Name() string                    // 数据源名称
	FetchVulnerabilities() ([]Vulnerability, error) // 获取漏洞数据
}

// GithubAdvisoriesSource GitHub安全公告数据源
type GithubAdvisoriesSource struct {
	token string // GitHub API token
}

// OSVSource OSV漏洞数据源
type OSVSource struct {
	baseURL string
}

// NVDSource NVD漏洞数据源
type NVDSource struct {
	apiKey string
}

// NewVulnerabilityDatabase 创建新的漏洞数据库实例
func NewVulnerabilityDatabase(dataPath string) *VulnerabilityDatabase {
	return &VulnerabilityDatabase{
		vulnerabilities: make(map[string][]Vulnerability),
		dataPath:       dataPath,
		sources: []VulnerabilitySource{
			&GithubAdvisoriesSource{},
			&OSVSource{baseURL: "https://api.osv.dev/v1/"},
			&NVDSource{},
		},
	}
}

// LoadData 从本地文件加载漏洞数据
func (db *VulnerabilityDatabase) LoadData() error {
	db.mu.Lock()
	defer db.mu.Unlock()

	if _, err := os.Stat(db.dataPath); os.IsNotExist(err) {
		return nil // 数据文件不存在,使用空数据库
	}

	data, err := os.ReadFile(db.dataPath)
	if err != nil {
		return fmt.Errorf("failed to read vulnerability database: %v", err)
	}

	var vulns []Vulnerability
	if err := json.Unmarshal(data, &vulns); err != nil {
		return fmt.Errorf("failed to parse vulnerability database: %v", err)
	}

	// 按包名索引漏洞
	db.vulnerabilities = make(map[string][]Vulnerability)
	for _, vuln := range vulns {
		db.vulnerabilities[vuln.PackageName] = append(db.vulnerabilities[vuln.PackageName], vuln)
	}

	return nil
}

// SaveData 将漏洞数据保存到本地文件
func (db *VulnerabilityDatabase) SaveData() error {
	db.mu.RLock()
	defer db.mu.RUnlock()

	// 将map转换为slice
	var vulns []Vulnerability
	for _, packageVulns := range db.vulnerabilities {
		vulns = append(vulns, packageVulns...)
	}

	data, err := json.MarshalIndent(vulns, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal vulnerability database: %v", err)
	}

	if err := os.MkdirAll(filepath.Dir(db.dataPath), 0755); err != nil {
		return fmt.Errorf("failed to create database directory: %v", err)
	}

	if err := os.WriteFile(db.dataPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write vulnerability database: %v", err)
	}

	return nil
}

// Update 从所有数据源更新漏洞数据
func (db *VulnerabilityDatabase) Update() error {
	db.mu.Lock()
	defer db.mu.Unlock()

	var allVulns []Vulnerability
	var errs []error

	// 并发从所有数据源获取数据
	var wg sync.WaitGroup
	vulnChan := make(chan []Vulnerability)
	errChan := make(chan error)

	for _, source := range db.sources {
		wg.Add(1)
		go func(src VulnerabilitySource) {
			defer wg.Done()
			vulns, err := src.FetchVulnerabilities()
			if err != nil {
				errChan <- fmt.Errorf("failed to fetch from %s: %v", src.Name(), err)
				return
			}
			vulnChan <- vulns
		}(source)
	}

	// 等待所有goroutine完成
	go func() {
		wg.Wait()
		close(vulnChan)
		close(errChan)
	}()

	// 收集结果
	for vulns := range vulnChan {
		allVulns = append(allVulns, vulns...)
	}

	for err := range errChan {
		errs = append(errs, err)
	}

	// 如果所有数据源都失败,返回错误
	if len(errs) == len(db.sources) {
		return fmt.Errorf("all vulnerability sources failed: %v", errs)
	}

	// 更新数据库
	db.vulnerabilities = make(map[string][]Vulnerability)
	for _, vuln := range allVulns {
		db.vulnerabilities[vuln.PackageName] = append(db.vulnerabilities[vuln.PackageName], vuln)
	}
	db.lastUpdate = time.Now()

	return nil
}

// GetVulnerabilities 获取指定包的漏洞信息
func (db *VulnerabilityDatabase) GetVulnerabilities(packageName string) []Vulnerability {
	db.mu.RLock()
	defer db.mu.RUnlock()

	// 尝试精确匹配
	if vulns, ok := db.vulnerabilities[packageName]; ok {
		return vulns
	}

	// 尝试模糊匹配
	var result []Vulnerability
	for name, vulns := range db.vulnerabilities {
		if strings.Contains(name, packageName) || strings.Contains(packageName, name) {
			result = append(result, vulns...)
		}
	}

	return result
}

// GetVulnerabilityByID 根据ID获取漏洞信息
func (db *VulnerabilityDatabase) GetVulnerabilityByID(id string) *Vulnerability {
	db.mu.RLock()
	defer db.mu.RUnlock()

	for _, vulns := range db.vulnerabilities {
		for _, vuln := range vulns {
			if vuln.ID == id {
				return &vuln
			}
		}
	}

	return nil
}

// FetchVulnerabilities 从GitHub安全公告获取漏洞数据
func (s *GithubAdvisoriesSource) FetchVulnerabilities() ([]Vulnerability, error) {
	// 实现从GitHub Security Advisories API获取数据
	// 使用GraphQL API获取更详细的信息
	return nil, nil
}

// Name 返回数据源名称
func (s *GithubAdvisoriesSource) Name() string {
	return "GitHub Security Advisories"
}

// FetchVulnerabilities 从OSV获取漏洞数据
func (s *OSVSource) FetchVulnerabilities() ([]Vulnerability, error) {
	resp, err := http.Get(s.baseURL + "vulns")
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var vulns []Vulnerability
	if err := json.Unmarshal(data, &vulns); err != nil {
		return nil, err
	}

	return vulns, nil
}

// Name 返回数据源名称
func (s *OSVSource) Name() string {
	return "OSV"
}

// FetchVulnerabilities 从NVD获取漏洞数据
func (s *NVDSource) FetchVulnerabilities() ([]Vulnerability, error) {
	// 实现从NVD API获取数据
	return nil, nil
}

// Name 返回数据源名称
func (s *NVDSource) Name() string {
	return "NVD"
}

// 注意事项:
// 1. 需要实现数据源的具体获取逻辑
// 2. 考虑添加数据缓存机制
// 3. 添加数据验证和清理
// 4. 实现增量更新
// 5. 添加数据压缩