package vulnerability

import (
	"fmt"
	"sort"
	"strings"
	"sync"

	"github.com/Masterminds/semver/v3"
	"github.com/your-org/ccscanner/pkg/models"
)

// Detector 漏洞检测器
type Detector struct {
	database *VulnerabilityDatabase
	cache    *sync.Map // 缓存检测结果
}

// DetectionResult 漏洞检测结果
type DetectionResult struct {
	Package      string         // 包名
	Version      string         // 版本
	Type         string         // 依赖类型
	Source       string         // 依赖来源
	Scope        string         // 依赖范围
	Vulnerabilities []Vulnerability // 发现的漏洞
	Metadata     map[string]interface{} // 额外元数据
}

// Risk 风险等级
type Risk string

const (
	RiskCritical Risk = "CRITICAL" // 严重
	RiskHigh     Risk = "HIGH"     // 高危
	RiskMedium   Risk = "MEDIUM"   // 中危
	RiskLow      Risk = "LOW"      // 低危
)

// NewDetector 创建新的漏洞检测器
func NewDetector(database *VulnerabilityDatabase) *Detector {
	return &Detector{
		database: database,
		cache:    &sync.Map{},
	}
}

// DetectVulnerabilities 检测依赖中的漏洞
func (d *Detector) DetectVulnerabilities(deps []*models.Dependency) ([]*DetectionResult, error) {
	var (
		results []*DetectionResult
		mu      sync.Mutex
		wg      sync.WaitGroup
		errChan = make(chan error, len(deps))
	)

	// 并发检测每个依赖
	for _, dep := range deps {
		wg.Add(1)
		go func(dep *models.Dependency) {
			defer wg.Done()

			// 检查缓存
			if cached, ok := d.cache.Load(d.cacheKey(dep)); ok {
				if result, ok := cached.(*DetectionResult); ok {
					mu.Lock()
					results = append(results, result)
					mu.Unlock()
					return
				}
			}

			// 检测漏洞
			result, err := d.detectSingle(dep)
			if err != nil {
				errChan <- fmt.Errorf("failed to detect vulnerabilities for %s: %v", dep.Name, err)
				return
			}

			// 缓存结果
			d.cache.Store(d.cacheKey(dep), result)

			mu.Lock()
			results = append(results, result)
			mu.Unlock()
		}(dep)
	}

	// 等待所有检测完成
	wg.Wait()
	close(errChan)

	// 检查错误
	var errs []error
	for err := range errChan {
		errs = append(errs, err)
	}
	if len(errs) > 0 {
		return results, fmt.Errorf("detection errors: %v", errs)
	}

	// 按风险等级排序
	sort.Slice(results, func(i, j int) bool {
		return d.getHighestRisk(results[i].Vulnerabilities) > d.getHighestRisk(results[j].Vulnerabilities)
	})

	return results, nil
}

// detectSingle 检测单个依赖的漏洞
func (d *Detector) detectSingle(dep *models.Dependency) (*DetectionResult, error) {
	// 创建检测结果
	result := &DetectionResult{
		Package:  dep.Name,
		Version:  dep.Version,
		Type:     dep.Type,
		Source:   dep.Source,
		Scope:    dep.Scope,
		Metadata: dep.Metadata,
	}

	// 获取包的所有漏洞
	vulns := d.database.GetVulnerabilities(dep.Name)
	if len(vulns) == 0 {
		return result, nil
	}

	// 解析当前版本
	currentVersion, err := semver.NewVersion(normalizeVersion(dep.Version))
	if err != nil {
		return result, fmt.Errorf("invalid version format: %v", err)
	}

	// 检查每个漏洞
	for _, vuln := range vulns {
		// 检查版本是否受影响
		affected := false
		for _, version := range vuln.Versions {
			constraint, err := semver.NewConstraint(normalizeVersion(version))
			if err != nil {
				continue
			}
			if constraint.Check(currentVersion) {
				affected = true
				break
			}
		}

		// 检查是否已修复
		if affected {
			for _, fixed := range vuln.Fixed {
				constraint, err := semver.NewConstraint(">=" + normalizeVersion(fixed))
				if err != nil {
					continue
				}
				if constraint.Check(currentVersion) {
					affected = false
					break
				}
			}
		}

		if affected {
			result.Vulnerabilities = append(result.Vulnerabilities, vuln)
		}
	}

	return result, nil
}

// getHighestRisk 获取最高风险等级
func (d *Detector) getHighestRisk(vulns []Vulnerability) Risk {
	if len(vulns) == 0 {
		return RiskLow
	}

	highest := RiskLow
	for _, vuln := range vulns {
		risk := d.calculateRisk(vuln)
		if risk > highest {
			highest = risk
		}
	}
	return highest
}

// calculateRisk 计算漏洞风险等级
func (d *Detector) calculateRisk(vuln Vulnerability) Risk {
	// 基于CVSS评分计算风险等级
	if vuln.CVSS >= 9.0 {
		return RiskCritical
	} else if vuln.CVSS >= 7.0 {
		return RiskHigh
	} else if vuln.CVSS >= 4.0 {
		return RiskMedium
	}
	return RiskLow
}

// cacheKey 生成缓存键
func (d *Detector) cacheKey(dep *models.Dependency) string {
	return fmt.Sprintf("%s@%s", dep.Name, dep.Version)
}

// normalizeVersion 标准化版本号
func normalizeVersion(version string) string {
	// 处理特殊版本格式
	if strings.HasPrefix(version, "v") {
		version = version[1:]
	}
	if strings.HasPrefix(version, "branch=") || strings.HasPrefix(version, "commit=") {
		return "0.0.0"
	}
	if strings.HasPrefix(version, ">=") {
		version = version[2:]
	}
	if strings.Contains(version, "...") {
		parts := strings.Split(version, "...")
		version = parts[0]
	}
	
	// 确保版本号有三个部分
	parts := strings.Split(version, ".")
	for len(parts) < 3 {
		parts = append(parts, "0")
	}
	
	return strings.Join(parts, ".")
}

// GetRiskSummary 获取风险摘要
func (d *Detector) GetRiskSummary(results []*DetectionResult) map[Risk]int {
	summary := make(map[Risk]int)
	for _, result := range results {
		risk := d.getHighestRisk(result.Vulnerabilities)
		summary[risk]++
	}
	return summary
}

// GetAffectedPackages 获取受影响的包列表
func (d *Detector) GetAffectedPackages(results []*DetectionResult) []string {
	var packages []string
	for _, result := range results {
		if len(result.Vulnerabilities) > 0 {
			packages = append(packages, result.Package)
		}
	}
	return packages
}

// GetVulnerabilityStats 获取漏洞统计信息
func (d *Detector) GetVulnerabilityStats(results []*DetectionResult) map[string]interface{} {
	stats := map[string]interface{}{
		"total_packages":     len(results),
		"affected_packages": 0,
		"total_vulnerabilities": 0,
		"risk_summary":      make(map[Risk]int),
		"cwe_summary":       make(map[string]int),
		"type_summary":      make(map[string]int),
	}

	for _, result := range results {
		if len(result.Vulnerabilities) > 0 {
			stats["affected_packages"] = stats["affected_packages"].(int) + 1
			stats["total_vulnerabilities"] = stats["total_vulnerabilities"].(int) + len(result.Vulnerabilities)

			risk := d.getHighestRisk(result.Vulnerabilities)
			stats["risk_summary"].(map[Risk]int)[risk]++

			for _, vuln := range result.Vulnerabilities {
				for _, cwe := range vuln.CWE {
					stats["cwe_summary"].(map[string]int)[cwe]++
				}
				stats["type_summary"].(map[string]int)[vuln.Type]++
			}
		}
	}

	return stats
}

// ClearCache 清除检测结果缓存
func (d *Detector) ClearCache() {
	d.cache = &sync.Map{}
}

// 注意事项:
// 1. 版本比较使用semver库
// 2. 使用并发提高检测效率
// 3. 缓存检测结果避免重复检测
// 4. 提供丰富的统计信息
// 5. 支持多种风险等级 
*/ 